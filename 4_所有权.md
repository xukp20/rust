### 所有权规则

每个值有一个变量作为所有者，只有一个所有者

所有者超出作用域之后会被删除



### String

字符串字面值是不可变的

使用from从字面值创建String

```rust
let s = String::from("Hello");
```

内存分配在Heap上，对于它的值，拥有它的变量离开作用范围时，内存释放

自动调用drop函数 



### 变量与数据交互

#### 移动

简单的基础数据类型在赋值时会复制，如int

String等复杂类型，赋值时stack上本身的数据被复制（ptr,len,capacity)，但是heap上的字符串内容没有复制，新生成的对象指向的是同一个Heap上的地址空间，这是 **原来的对象被废弃，称为Move**

```rust
let s1 = String::from("Hello");
let s2 = s1; 
```

如上之后，s1不能使用

s2 = s1的指针相当于浅拷贝，但是同时使得原来的指针失效，称为移动

离开当前作用域时，仅仅释放s2的Heap数据

#### 克隆

使用clone方法进行深拷贝

```rust
let s1 = String::from("Hello");
let s2 = s1.clone();
```

针对真实数据存在Heap上的类型，clone会将栈上的指针部分和堆上的数据同时拷贝一份

#### 赋值

对于int等基础数据类型，数据本身就在栈上，因此赋值操作进行的是赋值，即对象中不包括指针，没有在Heap中分配空间

```rust
let x = 1;
let y = x;
```

x,y均可用



#### Copy和Drop

Copy是一种trait，实现了Copy就会复制整个对象，实现了Drop就不能实现Copy

基础数据类型都有Copy，在Heap上分配的例如String都没有Copy



### 所有权与函数

函数传参的效果与赋值相同，若是基础数据类型，从函数返回之后还能使用；若为String等，传参相当于将所有权交给函数，从函数返回后原来的变量不能使用

返回值也是通过相同的方式转移所有权

#### 引用

1. 如果想要变量的所有权不消失，可以在函数中返回一个元组，把传入的参数再返回

2. 或者使用引用传参，传入变量的引用，称为 **借用**
   ```rust
   func(&s1);	// 传入s1的引用，是一个指向s1在栈上对象的对象
   
   ... 
   fn func(s: &String) -> usize {
       s.len()		// 返回s的长度，因为s不具有对应字符串的数据所有权，离开函数时不会drop
   }
   ```

   - 不可在函数中修改借用的值，可以使用mut声明可变的引用参数
     ```rust
     let mnt s = String::from("Hello");
     let s1 = &mut s;
     
     ...
     fn func(s: &mnt String)...
     ```

     - 同一个作用域中，对于一个变量只能有一个mut引用，防止数据竞争
     - 同理，不能同时存在一个可变引用和一个不可变引用

   - 悬垂引用
     rust不会出现对象指向的数据已经被释放的数据，编译时报错



### 切片

切片不持有所有权

字符串切片是指向字符串中一部分的引用

```rust
let hello = &s[0..5]; 	// 0-4字符的引用
```

对应的hello对象在栈中保存，指向s的数据，对应len为5，不具有所有权

字符串切片的类型为&str，字符串字面值也是&str

> 一般函数定义时都用&str参数，这样可以将String取完整切片传入